diff -Naur linux/arch/arm/mach-omap2/board-omap3beagle.c linux_src/arch/arm/mach-omap2/board-omap3beagle.c
--- linux/arch/arm/mach-omap2/board-omap3beagle.c	2011-04-21 10:05:52.378127912 +0530
+++ linux_src/arch/arm/mach-omap2/board-omap3beagle.c	2011-04-21 10:31:15.608127912 +0530
@@ -31,6 +31,8 @@
 
 #include <linux/regulator/machine.h>
 #include <linux/i2c/twl.h>
+#include <linux/i2c.h>
+#include <linux/i2c/tsc2007.h>
 
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
@@ -196,12 +198,13 @@
 
 static struct omap_dss_device beagle_dvi_device = {
 	.type = OMAP_DISPLAY_TYPE_DPI,
-	.name = "dvi",
-	.driver_name = "generic_panel",
-	.phy.dpi.data_lines = 24,
-	.reset_gpio = 170,
-	.platform_enable = beagle_enable_dvi,
-	.platform_disable = beagle_disable_dvi,
+        .name = "dvi",
+        .driver_name = "generic_panel",
+        .phy.dpi.data_lines = 24, 
+        .reset_gpio = 170,
+//        .platform_enable = beagle_enable_dvi,
+//        .platform_disable = beagle_disable_dvi,
+
 };
 
 static struct omap_dss_device beagle_tv_device = {
@@ -211,15 +214,39 @@
 	.phy.venc.type = OMAP_DSS_VENC_TYPE_SVIDEO,
 };
 
+static int beagle_enable_lcd(struct omap_dss_device *dssdev)
+{
+	if (gpio_is_valid(dssdev->reset_gpio))
+		gpio_set_value(dssdev->reset_gpio, 1);
+
+	return 0;
+}
+
+static void beagle_disable_lcd(struct omap_dss_device *dssdev)
+{
+	if (gpio_is_valid(dssdev->reset_gpio))
+		gpio_set_value(dssdev->reset_gpio, 0);
+}
+
+static struct omap_dss_device beagle_lcd_device = { 
+        .name                   = "lcd",
+        .driver_name            = "cmel_oled43_panel",
+        .type                   = OMAP_DISPLAY_TYPE_DPI,
+        .phy.dpi.data_lines     = 24, 
+        .reset_gpio             = 157,
+
+};
+
 static struct omap_dss_device *beagle_dss_devices[] = {
-	&beagle_dvi_device,
-	&beagle_tv_device,
+//	&beagle_dvi_device,
+//	&beagle_tv_device,
+	&beagle_lcd_device,
 };
 
 static struct omap_dss_board_info beagle_dss_data = {
 	.num_devices = ARRAY_SIZE(beagle_dss_devices),
 	.devices = beagle_dss_devices,
-	.default_device = &beagle_dvi_device,
+	.default_device = &beagle_lcd_device,
 };
 
 static struct platform_device beagle_dss_device = {
@@ -240,13 +267,13 @@
 {
 	int r;
 
-	r = gpio_request(beagle_dvi_device.reset_gpio, "DVI reset");
+	r = gpio_request(beagle_lcd_device.reset_gpio, "DVI reset");
 	if (r < 0) {
 		printk(KERN_ERR "Unable to get DVI reset GPIO\n");
 		return;
 	}
 
-	gpio_direction_output(beagle_dvi_device.reset_gpio, 0);
+	gpio_direction_output(beagle_lcd_device.reset_gpio, 0);
 }
 
 #include "sdram-micron-mt46h32m32lf-6.h"
@@ -260,6 +287,10 @@
 	{}	/* Terminator */
 };
 
+static struct omap_lcd_config omap3_beagle_lcd_config __initdata = {
+	.ctrl_name	= "internal",
+};
+
 static struct regulator_consumer_supply beagle_vmmc1_supply = {
 	.supply			= "vmmc",
 };
@@ -268,6 +299,14 @@
 	.supply			= "vmmc_aux",
 };
 
+static struct regulator_consumer_supply beagle_vdda_dac_supply =
+	REGULATOR_SUPPLY("vdda_dac", "omapdss");
+
+static struct regulator_consumer_supply beagle_vdds_supplies[] = {
+	REGULATOR_SUPPLY("vdds_sdi", "omapdss"),
+	REGULATOR_SUPPLY("vdds_dsi", "omapdss"),
+};
+
 static struct gpio_led gpio_leds[];
 
 static int beagle_twl_gpio_setup(struct device *dev,
@@ -337,6 +376,7 @@
 	},
 	.num_consumer_supplies	= 1,
 	.consumer_supplies	= &beagle_vmmc1_supply,
+
 };
 
 /* VSIM for MMC1 pins DAT4..DAT7 (2 mA, plus card == max 50 mA) */
@@ -366,6 +406,7 @@
 	},
 	.num_consumer_supplies	= 1,
 	.consumer_supplies	= &beagle_vdac_supply,
+//	.consumer_supplies      = &beagle_vdda_dac_supply,
 };
 
 /* VPLL2 for digital video outputs */
@@ -381,6 +422,9 @@
 	},
 	.num_consumer_supplies	= 1,
 	.consumer_supplies	= &beagle_vdvi_supply,
+//	.num_consumer_supplies  =  ARRAY_SIZE(beagle_vdds_supplies),
+//        .consumer_supplies      = beagle_vdds_supplies,
+
 };
 
 static struct twl4030_usb_data beagle_usb_data = {
@@ -419,6 +463,45 @@
 	},
 };
 
+/* TouchScreen */
+#define OMAP3_BEAGLETOUCH_TS_GPIO 136
+static int tsc2007_get_pendown_state(void)
+{
+	return !gpio_get_value(OMAP3_BEAGLETOUCH_TS_GPIO);
+}
+
+static int omap3beagletouch_tsc2007_init(void)
+{
+	int gpio = OMAP3_BEAGLETOUCH_TS_GPIO;
+	int ret = 0;
+
+	ret = gpio_request(gpio, "tsc2007_pen_down");
+	if (ret < 0) {
+		printk(KERN_ERR "Failed to request GPIO %d for "
+				"tsc2007 pen down IRQ\n", gpio);
+		return ret;
+	}
+
+	gpio_direction_input(gpio);
+
+	return ret;
+}
+
+static struct tsc2007_platform_data tsc2007_info = {
+	.model			= 2007,
+	.x_plate_ohms		= 180,
+	.get_pendown_state	= tsc2007_get_pendown_state,
+	.init_platform_hw	= omap3beagletouch_tsc2007_init,
+};
+
+static struct i2c_board_info __initdata ts_i2c_clients[] = {
+	{
+		I2C_BOARD_INFO("tsc2007", 0x48),
+		.irq	= OMAP_GPIO_IRQ(OMAP3_BEAGLETOUCH_TS_GPIO),
+		.platform_data	= &tsc2007_info,
+	},
+};
+
 static struct i2c_board_info __initdata beagle_i2c_eeprom[] = {
        {
                I2C_BOARD_INFO("eeprom", 0x50),
@@ -431,7 +514,8 @@
 			ARRAY_SIZE(beagle_i2c_boardinfo));
 	/* Bus 3 is attached to the DVI port where devices like the pico DLP
 	 * projector don't work reliably with 400kHz */
-	omap_register_i2c_bus(3, 100, beagle_i2c_eeprom, ARRAY_SIZE(beagle_i2c_eeprom));
+//	omap_register_i2c_bus(3, 100, beagle_i2c_eeprom, ARRAY_SIZE(beagle_i2c_eeprom));
+	omap_register_i2c_bus(3, 100, ts_i2c_clients, ARRAY_SIZE(ts_i2c_clients));
 	return 0;
 }
 
@@ -488,8 +572,14 @@
 	},
 };
 
+static struct omap_board_config_kernel omap3_beagle_config[] __initdata = {
+	{ OMAP_TAG_LCD,		&omap3_beagle_lcd_config },
+};
+
 static void __init omap3_beagle_init_irq(void)
 {
+	omap_board_config = omap3_beagle_config;
+	omap_board_config_size = ARRAY_SIZE(omap3_beagle_config);
 	omap2_init_common_hw(mt46h32m32lf6_sdrc_params,
 			     mt46h32m32lf6_sdrc_params);
 	omap_init_irq();
@@ -564,6 +654,13 @@
 	.power			= 100,
 };
 
+/* Pins for the BeagleTouch OLED */
+#define CS_PIN          139
+#define MOSI_PIN        144
+#define CLK_PIN         138
+#define RESET_PIN       137
+#define PANEL_PWR_PIN   143
+
 static void __init omap3_beagle_init(void)
 {
 	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
@@ -573,6 +670,14 @@
 			ARRAY_SIZE(omap3_beagle_devices));
 	omap_serial_init();
 
+	/* BeagleTouch OLED */
+    omap_mux_init_gpio(CS_PIN, OMAP_PIN_OUTPUT);
+    omap_mux_init_gpio(MOSI_PIN, OMAP_PIN_OUTPUT);
+    omap_mux_init_gpio(CLK_PIN, OMAP_PIN_OUTPUT);
+    omap_mux_init_gpio(RESET_PIN, OMAP_PIN_OUTPUT);
+    omap_mux_init_gpio(PANEL_PWR_PIN, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(OMAP3_BEAGLETOUCH_TS_GPIO, OMAP_PIN_INPUT_PULLUP);
+
 	omap_mux_init_gpio(170, OMAP_PIN_INPUT);
 	gpio_request(170, "DVI_nPD");
 	/* REVISIT leave DVI powered down until it's needed ... */
diff -Naur linux/drivers/input/touchscreen/tsc2007.c linux_src/drivers/input/touchscreen/tsc2007.c
--- linux/drivers/input/touchscreen/tsc2007.c	2011-04-21 10:05:38.148127912 +0530
+++ linux_src/drivers/input/touchscreen/tsc2007.c	2011-04-21 10:32:03.238127912 +0530
@@ -311,12 +311,24 @@
 
 	if (pdata->init_platform_hw)
 		pdata->init_platform_hw();
-
+/*
 	err = request_irq(ts->irq, tsc2007_irq, 0,
 			client->dev.driver->name, ts);
 	if (err < 0) {
 		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
 		goto err_free_mem;
+	} */
+
+	if (request_irq(ts->irq, tsc2007_irq, IRQF_TRIGGER_FALLING,
+			client->dev.driver->name, ts)) {
+		dev_info(&client->dev, "trying pin change workaround on irq %d\n", ts->irq);
+		
+	err = request_irq(ts->irq, tsc2007_irq,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
+				  client->dev.driver->name, ts);
+		if (err) {
+			dev_err(&client->dev, "irq %d busy?\n", ts->irq);
+			goto err_free_mem;
+		}
 	}
 
 	/* Prepare for touch readings - power down ADC and enable PENIRQ */
diff -Naur linux/drivers/video/omap2/displays/Kconfig linux_src/drivers/video/omap2/displays/Kconfig
--- linux/drivers/video/omap2/displays/Kconfig	2011-04-21 10:05:34.648127912 +0530
+++ linux_src/drivers/video/omap2/displays/Kconfig	2011-04-21 10:29:33.818127912 +0530
@@ -44,4 +44,10 @@
 	select BACKLIGHT_CLASS_DEVICE
 	help
 	  This is the LCD panel used on Nokia N900
+
+config PANEL_CMEL_OLED43
+        tristate "CMEL OLED43 LCD Panel"
+        depends on OMAP2_DSS
+        help
+          OLED Panel used on BeagleSlide
 endmenu
diff -Naur linux/drivers/video/omap2/displays/Makefile linux_src/drivers/video/omap2/displays/Makefile
--- linux/drivers/video/omap2/displays/Makefile	2011-04-21 10:05:34.648127912 +0530
+++ linux_src/drivers/video/omap2/displays/Makefile	2011-04-21 10:29:43.368127912 +0530
@@ -1,4 +1,5 @@
 obj-$(CONFIG_PANEL_GENERIC) += panel-generic.o
+obj-$(CONFIG_PANEL_CMEL_OLED43) += panel-cmel-oled43.o
 obj-$(CONFIG_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
 obj-$(CONFIG_PANEL_SHARP_LQ043T1DG01) += panel-sharp-lq043t1dg01.o
 
diff -Naur linux/drivers/video/omap2/displays/panel-cmel-oled43.c linux_src/drivers/video/omap2/displays/panel-cmel-oled43.c
--- linux/drivers/video/omap2/displays/panel-cmel-oled43.c	1970-01-01 05:30:00.000000000 +0530
+++ linux_src/drivers/video/omap2/displays/panel-cmel-oled43.c	2011-04-21 10:29:12.448127911 +0530
@@ -0,0 +1,325 @@
+/*
+ * OLED panel driver for CMEL OLED43
+ *
+ * Author: Chris Ladden <chris.ladden@liquidware.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <linux/fb.h>
+
+#include <plat/display.h>
+
+#define CS_PIN          139
+#define MOSI_PIN        144
+#define CLK_PIN         138
+#define RESET_PIN       137
+#define PANEL_PWR_PIN   143
+
+#define digitalWrite(PIN,VALUE) (gpio_direction_output(PIN,VALUE))
+
+#define CS_LOW digitalWrite(CS_PIN, 0)
+#define CS_HIGH digitalWrite(CS_PIN, 1)
+#define MOSI_LOW digitalWrite(MOSI_PIN, 0)
+#define MOSI_HIGH digitalWrite(MOSI_PIN, 1)
+#define CLK_LOW digitalWrite(CLK_PIN, 0)
+#define CLK_HIGH digitalWrite(CLK_PIN, 1)
+#define RESET_LOW digitalWrite(RESET_PIN, 0)
+#define RESET_HIGH digitalWrite(RESET_PIN, 1)
+#define PANEL_PWR_LOW digitalWrite(PANEL_PWR_PIN, 0)
+#define PANEL_PWR_HIGH digitalWrite(PANEL_PWR_PIN, 1)
+
+/*
+ *   Video Timings
+ *       
+ *   Frame Rate = 1/((vbp + vfp + 272)*(hbp + hfp + 480)/pixel_clock)
+ *   Where hfp must be > 30,
+ *         hbp must be = 102,
+ *         vfp must be > 10,
+ *         vbp must be = 20,
+ */
+static struct omap_video_timings oled43_timings = {
+	.x_res = 480,
+	.y_res = 272,
+
+	.pixel_clock	= 12342,
+
+	.hsw		= 30,
+	.hfp		= 31,
+	.hbp		= 102,
+
+	.vsw		= 3,
+	.vfp		= 11,
+	.vbp		= 20,
+};
+
+/* Initialize the software SPI interface */
+static void oled43_spi_init(void) {
+    CS_HIGH;
+    MOSI_HIGH;
+    CLK_HIGH;
+}
+
+/* Write an 8-bit byte onto the SPI bus */
+static void oled43_spi_write8(uint8_t data) {
+uint8_t ii;
+uint8_t bit;
+
+    for (ii=0; ii < 8; ii++) {
+        bit = (data >> (7-ii)) & 1;
+        if (bit) {
+            MOSI_HIGH;
+        } else {
+            MOSI_LOW;
+        }
+
+        CLK_LOW;		//clock the data in
+        CLK_HIGH;
+    }
+}
+
+/* Write a value to the OLED panel */
+static void oled43_writeReg(uint8_t index, uint8_t val) {
+    CS_LOW;
+    oled43_spi_write8((index << 1));
+    oled43_spi_write8(val);
+    CS_HIGH;
+}
+
+static int oled43_hardware_init(void) {
+uint8_t brightness;
+double percent; 
+
+	/* Panel init sequence from the panel datasheet */
+	PANEL_PWR_LOW;						// just to be sure, hold the oled power supply off
+	RESET_LOW;							// panel in reset
+	oled43_spi_init();					// init spi interface
+	RESET_HIGH;							// panel out of reset
+
+    oled43_writeReg(0x04, 0x23); //DISPLAY_MODE2
+    oled43_writeReg(0x05, 0x82); //DISPLAY_MODE3
+
+    oled43_writeReg(0x07, 0x0F); //DRIVER_CAPABILITY
+    oled43_writeReg(0x34, 0x18);
+    oled43_writeReg(0x35, 0x28);
+    oled43_writeReg(0x36, 0x16);
+    oled43_writeReg(0x37, 0x01);
+
+    oled43_writeReg(0x03, 35);   //VGAM1_LEVEL
+
+    /* Set the brightness
+     *  0x20 - 200 nits
+     *  0x1E - 175 nits
+     *  0x1C - 150 nits
+     *  0x17 - 100 nits
+     *  0x14 -  70 nits
+     *  0x11 -  50 nits */
+    brightness = 0x14;
+    percent = ((double)brightness)/
+               (0x20) * 100.0;
+
+    printk(KERN_INFO "cmel_oled43_panel: Setting brightness to %d percent\n", (int)percent);
+    
+    oled43_writeReg(0x3A, brightness);    
+
+    /* Display ON */
+    oled43_writeReg(0x06, 0x03); //POWER_CTRL1
+
+	PANEL_PWR_HIGH;
+    
+	return 0;
+}
+
+static int oled43_panel_power_on(struct omap_dss_device *dssdev)
+{
+	int r;
+
+	oled43_hardware_init();
+
+	r = omapdss_dpi_display_enable(dssdev);
+	if (r)
+		goto err0;
+
+	if (dssdev->platform_enable) {
+		r = dssdev->platform_enable(dssdev);
+		if (r)
+			goto err1;
+	}
+
+	return 0;
+err1:
+	omapdss_dpi_display_disable(dssdev);
+err0:
+	return r;
+}
+
+static void oled43_panel_power_off(struct omap_dss_device *dssdev)
+{
+    /* Turn off the power supply */
+	PANEL_PWR_LOW; 
+}
+
+static void oled43_panel_led_set(struct led_classdev *cdev, enum led_brightness value)
+{
+	int level;
+    
+    level = value / 8; //scaled for the controller
+    if (value <= 20) {
+        /* brightness threshold reached, turning off */
+        printk(KERN_INFO "cmel_oled43_panel: brightness set at or below threshold, turning OFF\n");
+        level = 0;
+    }
+    oled43_writeReg(0x3A, level);
+}
+
+static struct led_classdev cmel_oled43_panel_led_ops = {
+    .name = "lcd-backlight",
+	.brightness_set = oled43_panel_led_set,
+    .brightness = 159,
+    .max_brightness = 255,
+};
+
+static int oled43_panel_probe(struct omap_dss_device *dssdev)
+{
+    struct led_classdev	*cdev;
+
+	dssdev->panel.config = OMAP_DSS_LCD_TFT;
+	dssdev->panel.timings = oled43_timings;
+    
+	cdev = led_classdev_register((struct device *)&dssdev->dev,
+			&cmel_oled43_panel_led_ops);
+
+	return 0;
+}
+
+static void oled43_panel_remove(struct omap_dss_device *dssdev)
+{
+    oled43_panel_power_off(dssdev);
+}
+
+static int oled43_panel_enable(struct omap_dss_device *dssdev)
+{
+	int r = 0;
+	pr_info("cmel_oled43_panel: panel_enable begin\n");
+	r = oled43_panel_power_on(dssdev);
+	if (r)
+		return r;
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+	pr_info("cmel_oled43_panel: panel_enable end\n");
+
+	return 0;
+}
+
+static void oled43_panel_disable(struct omap_dss_device *dssdev)
+{
+	oled43_panel_power_off(dssdev);
+
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+}
+
+static int oled43_panel_suspend(struct omap_dss_device *dssdev)
+{
+	oled43_panel_power_off(dssdev);
+	dssdev->state = OMAP_DSS_DISPLAY_SUSPENDED;
+	pr_info("cmel_oled43_panel: panel_suspend\n");
+	return 0;
+}
+
+static int oled43_panel_resume(struct omap_dss_device *dssdev)
+{
+	int r = 0;
+	pr_info("cmel_oled43_panel: panel_resume\n");
+	r = oled43_panel_power_on(dssdev);
+	if (r)
+		return r;
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+
+	return 0;
+}
+
+static void oled43_panel_set_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	dpi_set_timings(dssdev, timings);
+}
+
+static void oled43_panel_get_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	*timings = dssdev->panel.timings;
+}
+
+static int oled43_panel_check_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	return dpi_check_timings(dssdev, timings);
+}
+
+static struct omap_dss_driver oled43_driver = {
+	.probe		= oled43_panel_probe,
+	.remove		= oled43_panel_remove,
+
+	.enable		= oled43_panel_enable,
+	.disable	= oled43_panel_disable,
+	.suspend	= oled43_panel_suspend,
+	.resume		= oled43_panel_resume,
+
+	.set_timings	= oled43_panel_set_timings,
+	.get_timings	= oled43_panel_get_timings,
+	.check_timings	= oled43_panel_check_timings,
+
+	.driver         = {
+		.name   = "cmel_oled43_panel",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init oled43_panel_drv_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "cmel_oled43_panel: init panel\n");
+
+	/* Request GPIO pins used for the panel */
+    printk(KERN_INFO "cmel_oled43_panel: requesting GPIOs\n");
+	gpio_request(CS_PIN, "OLED43_CS_PIN");
+	gpio_request(MOSI_PIN, "OLED43_MOSI_PIN");
+	gpio_request(CLK_PIN, "OLED43_CLK_PIN");
+	gpio_request(RESET_PIN, "OLED43_RESET_PIN");
+	gpio_request(PANEL_PWR_PIN, "OLED43_PANEL_PWR_PIN");
+    
+    /* Hold the power supply off until enabled */
+	PANEL_PWR_LOW;
+
+	ret = omap_dss_register_driver(&oled43_driver);
+	if (ret != 0)
+		pr_err("cmel_oled43: Unable to register panel driver: %d\n", ret);
+
+	printk(KERN_INFO "cmel_oled43_panel: done\n");
+	return ret;
+}
+
+static void __exit oled43_panel_drv_exit(void)
+{
+	omap_dss_unregister_driver(&oled43_driver);
+}
+
+module_init(oled43_panel_drv_init);
+module_exit(oled43_panel_drv_exit);
+MODULE_LICENSE("GPL");
